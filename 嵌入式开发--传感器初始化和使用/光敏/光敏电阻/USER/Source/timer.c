#include "timer.h"
#include "usart1.h"
#include "stdio.h"
/**************************************************
TIM14_CH1  PA7  实现输入捕获出功能
参数： psc是预分频值（1~65536）
	   arr是重装载值（0~65535）
**************************************************/
void TIM14_CH1_Init(u16 psc,u16 arr)
{
		/******GPIO复用**********/	 
		RCC->AHB1ENR  |=1<<0;         //GPIOA时钟源选择
		GPIOA->MODER  &=~(3<<(2*7));  //GPIOA.7模式配置
		GPIOA->MODER  |=2<<(2*7);     //复用模式
		GPIOA->AFR[0] &=~(0xful<<(4*7));//GPIO复用功能选择
		GPIOA->AFR[0] |=9ul<<(4*7);     //复用功能选择AF9(TIM14_CH1)
		/*****时基单元配置*******/	  
		RCC->APB1ENR |=1<<8;  //使能TIM14时钟源        
 
		TIM14->CR1 |=1<<7;     //自动重载预装载使能      
		TIM14->CR1 &=~(1<<3);  //计数模式（循环计数）
		TIM14->CR1 &=~(1<<2);  //选择更新请求源          
		TIM14->CR1 &=~(1<<1);  //使能更新                
   
		TIM14->PSC  =psc-1;    //配置预分频器   

		TIM14->ARR  =arr;      //配置自动重装载寄存器    
		TIM14->EGR |=1<<0;     //手动更新，初始化计数器  
		TIM14->SR  &=~(1<<0);  //清除更新标志位 
		
		//输入捕获模式配置           
		TIM14->CCMR1 &=~(0xf<<4);//无滤波器
		TIM14->CCMR1 |=7<<4;	 //无滤波器
		TIM14->CCMR1 &=~(0x3<<2);//无预分频
		TIM14->CCMR1 &=~(0x3<<0);//定义通道方向
		TIM14->CCMR1 |=1<<0;
		
		TIM14->CCER  &=~(1<<3);  //选择触发捕获操作的极性
		TIM14->CCER  &=~(1<<1);  //选择上升沿触发

		TIM14->DIER |=1<<0;      //使能更新中断 
		TIM14->DIER |=1<<1;      //使能捕获比较1中断 
		NVIC_SetPriority(TIM8_TRG_COM_TIM14_IRQn,NVIC_EncodePriority (5, 1, 1));
		NVIC_EnableIRQ( TIM8_TRG_COM_TIM14_IRQn );     //通道使能		
		//捕获/比较中断使能
		TIM14->CCER  |=1<<0;    //通道输出使能
 		TIM14->CR1 |=1<<0;      //计数器使能 
}

/**************************************************
TIM14_CH1 中断服务函数
参数：无
作用：捕获TIM13PWM 波的高电平时间
**************************************************/
u32 capture_H=0;
u32 capture_L=0;
u8  Get_Glag=0;
void TIM8_TRG_COM_TIM14_IRQHandler(void)
{

	static u8 update_flag=0;
	static u8 flag=1;
	TIM14->CNT  =0 ; //清空计数器，进行计数边沿的对齐，
		//放后面误差较大。
		if( TIM14->SR &(1<<1) )  //产生捕获中断
	{
		TIM14->SR &=~(1<<1);
		if( flag )    //flag初始为1，上升沿触发
		{					
		  capture_L =update_flag*1000 + TIM14->CCR1; //1000是初始化的时候传入的TIM14的重载值	
		}
		else          //下降沿触发
		{
		  capture_H =update_flag*1000 + TIM14->CCR1; //1000是初始化的时候传入的TIM14的重载值	                                         //即每发生一次更新事件，CNT计数的一个重载值的数
		}	
		Get_Glag =1;
		update_flag =0;
		TIM14->CCER  ^=1<<1;    //切换检测边沿
		flag =!flag;            //下次执行另一部分
	}
	if( TIM14->SR &(1<<0) )
	{
		update_flag++;
		TIM14->SR &=~(1<<0);
	}
	
}

/**************************************************
TIM13_CH1  PA6  实现PWM输出功能
参数： psc是预分频值（1~65536）
	   arr是重装载值（0~65535）
注意：PWM模式选择模式1：在递增计数模式下，只要 TIMx_CNT<TIMx_CCR1，通道 1 便为有效状态，否则为无效状态。
			输出极性选择有效电平为低电平
			则，低电平的占空比为  ccr1/arr ;PA6驱动LED3，低电平有效
			低电平的占空比越大，LED1越亮。
**************************************************/
void TIM13_CH1_Init(u16 psc,u16 arr,u16 ccr1)
{
		/******GPIO复用**********/	 
		RCC->AHB1ENR  |=1<<0;         //GPIOA时钟源选择
		GPIOA->MODER  &=~(3<<(2*6));  //GPIOA.6模式配置
		GPIOA->MODER  |=2<<(2*6);     //复用模式
		GPIOA->AFR[0] &=~(0xful<<(4*6));//GPIO复用功能选择
		GPIOA->AFR[0] |=9ul<<(4*6);     //复用功能选择AF9(TIM14_CH1)
		/*****时基单元配置*******/	  
		RCC->APB1ENR |=1<<7;  //使能TIM13时钟源        
 
		TIM13->CR1 |=1<<7;     //自动重载预装载使能      
		TIM13->CR1 &=~(1<<3);  //计数模式（循环计数）
		TIM13->CR1 &=~(1<<2);  //选择更新请求源          
		TIM13->CR1 &=~(1<<1);  //使能更新                
   
		TIM13->PSC  =psc-1;    //配置预分频器   

		TIM13->ARR  =arr;      //配置自动重装载寄存器    
		TIM13->EGR |=1<<0;     //手动更新，初始化计数器  
		TIM13->SR  &=~(1<<0);  //清除更新标志位 
    /*****PWM输出模式配置*******/	 
		TIM13->CCMR1 &=~(3<<0);//定义通道方向为输出
		TIM13->CCMR1 &=~(7<<4);//输出比较模式
		TIM13->CCMR1 |=7<<4;   //选择PWM模式2
		TIM13->CCER  |=1<<1;   //输出比较的极性选择有效电平为低电平
		TIM13->CCER  |=1<<3;   //捕获/比较寄存器预装载使能
		TIM13->CCR1  = ccr1;   //写入输出比较值
	
		TIM13->CCER  |=1<<0;    //通道输出使能
 		TIM13->CR1 |=1<<0;      //计数器使能 
}






